---
title: "Lab1 - Esther Xuanpei Ouyang"
author: "Esther Xuanpei Ouyang"
date: "1/22/2018"
output: pdf-document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## 1) Basic Vector and Matrix manipulations in R

```{r}
x = 1:9

matrix(data = x, nrow = 3, ncol = 3, byrow = FALSE)

matrix(data = x, nrow = 3, ncol = 3, byrow = TRUE)

diag(x = 1, 5, 5)

a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)

A = cbind(a1, a2, a3)

b1 <- c(1, 4, 5, 8, 9)
b2 <- c(1.22, 1.05, 3.60, 0.40, 2.54) 
b3 <- c(20, 40, 30, 80, 100)

B = rbind(b1, b2, b3)

A%*%B
B%*%A
t(A)%*%t(B)
t(B)%*%t(A)


head(iris)

lincombo = 1*iris[1] + 2*iris[2] + 3*iris[3] + 4*iris[4]
lincombo

v = 1:5
vnorm = function(x) {
  return(sqrt(sum(x*x)))
}
vnorm(v)
unit_v = v / vnorm(v)
unit_v

is_square = function(x) {
  dimen = dim(x)
  return (dimen[1] == dimen[2])
}

x = 1:8
test1 = matrix(x, 2, 4)
y = 1:9
test2 = matrix(y, 3, 3)
is_square(test1)
is_square(test2)

mtrace = function(mat) {
  if (!is_square(mat)) {
    return (0)
  } else {
    dimen = dim(mat)
    I = diag(1, dimen[1], dimen[2])
    return(sum(sum(mat*I)))
  }
}

test1 = matrix(1:9, 3, 3)
test2 = matrix(2:10, 3, 3)
test3 = test1 + test2
# Test 1
mtrace(test1) + mtrace(test2)
mtrace(test3)

# Test 2
test4 = 3 * test1
mtrace(test1) * 3
mtrace(test4)

# Test3
X = test1
Y = test2
XtY = t(X)%*%Y
XYt = X%*%t(Y)
YtX = t(Y)%*%X
YXt = Y%*%t(X)

mtrace(XtY)
mtrace(XYt)
mtrace(YtX)
mtrace(YXt)
```
## 2) Transformation and Scaling Operations

```{r}
head(mtcars)

# Create a matrix M with variables mpg, disp, hp, drat, and wt.
M = mtcars[, c(1,3,4,5,7)]
M

# Use apply() to compute the vector containing the means of the columns in M
apply(M, 2, mean)

# Compute a matrix Mc of mean-centered data applying the function scale() on M (do NOT use the argument scale = TRUE).
Mc = scale(M, scale = FALSE)
Mc

# Confirm that variables in Mc are mean-centered by calculating the vector of column-means Use the function sweep() to mean-center M by sweeping out the vector of column means.
M.mean = apply(M, 2, mean)
Msweep = sweep(M, 2, M.mean)

# Compare this result with Mc (you should get the same values).
all(Mc == Msweep)

# Compute a vector of column maxima from M.
Mmax = apply(M, 2, max)
Mmax

# Use sweep() to scale the columns of M by dividing by the column maxima.
sweep(M, 2, Mmax,"/")

# Compute a matrix in which all columns of M are scaled such that they have minimum = 0 and maximum = 1
Mmax = apply(M, 2, max)
Mmin = apply(M, 2, min)
Mrange = Mmax - Mmin
scale(M , center = Mmin, scale = Mrange)

# Without using the function cov(), compute the sample covariance matrix of the variables in M: mpg, disp, hp, drat, and wt.
n = dim(mtcars)[1]
Mcov = (t(Mc)%*%Mc)/(n-1)
Mcov
# Without using the function cor(), compute the correlation matrix of the variables in M: mpg, disp, hp, drat, and wt.
standardize_M = scale(M) # variance = 1
Mcor = (t(standardize_M)%*%standardize_M)/(n-1)
Mcor
```

```{r}
cyl = factor(mtcars$cyl)

dummify = function(char_vector, all) {
  
  char_vector = cyl
  #all = FALSE
  #n_class = nlevels(char_vector)
  res = matrix(0,1,n_class)
  dummy_mat = diag(1, n_class, n_class)
  if (!all) {
    dummy_mat = dummy_mat[, -1]
  }
  #print(dummy_mat)
  #print(dummy_mat[3, ])
  class_level = c(levels(char_vector))
  print(class_level)
  for (class in char_vector) {
    class_i = match(class, class_level)
    print(class_i)
    res = rbind(res, dummy_mat[class_i, ])
  }
  return(res[-1,])
}

dummify(cyl, all = TRUE)
dummify(cyl, all = FALSE)

gear = factor(mtcars$gear)

crosstable = function(vec1, vec2) {
  dummy1 = dummify(vec1, all = TRUE)
  dummy2 = dummify(vec2, all = TRUE)
  return(t(dummy1)%*%dummy2)
}

xtb <- crosstable(cyl, gear)
xtb
```

